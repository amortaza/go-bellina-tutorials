# Tutorial 6

## Click Plugin

> [On Github: Tutorial 6](tutorial-06-Plugin-Click)

For clarity, some of the code will be hidden.  View the full source code at the repository.

We will skip over material that has been covered in previous tutorials.

&nbsp;

The `main.go` example in `tutorial-06-Plugin-Click` is using the `click` plugin from `amortaza/go-bellina-plugins/click` which is 99% similar to the click plugin we are going to develop in this tutorial.

We have been introduced to many of the concepts needed to be able to create our first plugin - `Click`.

As a plugin designer, there is no preconditions on how things should be laid out, except to make usage of plugin as useful and easy as possible.

First, lets design what the plugin does, and how it is used.

## Click plugin API design

Here is what the API will look like:

```
click.On( callback func(interface{}) )

click.On_WithLifeCycle( successCallback, 
						onButtonDown, 
                        onButtonUpAndMiss func(interface{})
```

Here is why...

* `Click` maybe used without instantiating any object

* `Click` will call a callback function when a node is *clicked*

* *clicked* is defined as a mouse-down event followed by a mouse-up event on the same node

* Pressing mouse button on a node, but releasing the mouse button on a different node is *not* a click

* To make the plugin more useful, we can provide `life-cycle` methods
	* When the click life-cycle starts, there will be a callback
    * When the click action completes successfully, there will be a callback
    * When the click action is incomplete (ie. see *clicked* definition above), there will be a callback

* Because the simple case of a successful click notification is the 90% case, we will make it easier to use

* The full life-cycle setup, is more complicated and far less common so we will make that a separate function

## Example Usage

```
bl.Div()
{
	bl.Id("one")
    bl.Pos(100,100)
    bl.Dim(200,200)
    border.Fill(0,50,0)
    
    click.On(func(e interface{}) {
        clickEvent := e.(*click.Event)
        
    	fmt.Println("Clicked on", clickEvent.Target.Id, clickEvent.X, clickEvent.Y)
    })
}
bl.End()
```

## Implementation of Click Plugin

We'll put the code in two files.

![dir](dir.jpg?raw=true "Dir")

The public API in `click.go` and everything else in `logic.go`

### click.go

```
package click

import (
	"github.com/amortaza/go-bellina"
)
```

When the callbacks are called, the information about the click event can be packaged in the `Event` structure below.

> Note that this event is *not* implementing the `bl.Event` interface.  It could have, but it does not.  Therefore, we will not be able to use `bl.FireEvent(event)`.  This is not a problem, because this is not our use-case.  If it is found useful to be able to have listeners for the events generated by our click plugin, then we can easily add that.  

```
type Event struct {
	X, Y int
	Target *bl.Node
}
```

The `(X, Y)` will inform where in the node the click happened (relative to the node's local coordinates).

The `Target` will point to the Node itself.

Because the definition of the plugin callbacks and the event dispatching is happening within the same Bellina frame, the pointer of the node will be valid when the callback is made.

Do *not* hold on Node pointers, because they are invalidated *every* frame.  The node `Id` should be kept instead.

```
// click.On( cb )
func On(cb func(interface{})) {
	logic(cb, nil, nil)
}

// click.On_WithLifeCycle( successCb, downCb, upAndMissCb )
func On_WithLifeCycle(cb, onDown, onUpAndMiss func(interface{})) {
	logic(successCb, downCb, upAndMissCb)
}

```

### logic.go

When mouse is clicked on the node, we need to know about it.

We can use the short-term registration.  We can explore how using the long-term registration would have changed our code.  

But why not use the `bl.OnMouseButton(...)` on the node?

The `RegisterShortTerm` function is a global listener for mouse-button events.  So even if an unrelated node is mouse-button'd on, the registered callback is called.

This is important because if a node other than our original node gets a mouse button event, the original node needs to know about it so it can cancel the `click`.


```
func logic(cb, onDown, onUpAndMiss func(interface{})) {
	bl.RegisterShortTerm(bl.EventType_Mouse_Button, func(event bl.Event) {
    	e := event.(*bl.MouseButtonEvent)
	})
}
```

If the action is *Button Down* then we are half-way through our click!

Lets start keeping track of the node that we *Button Down* on.

```
var gLastNodeId string // i.e. last node that we saw
```

```
func logic(cb, onDown, onUpAndMiss func(interface{})) {
	bl.RegisterShortTerm(bl.EventType_Mouse_Button, func(event bl.Event) {
    	e := event.(*bl.MouseButtonEvent)
        
        if e.ButtonAction == bl.Button_Action_Down {

			gLastNodeId = e.Target.Id
		}
	})
}
```

If the action is *Button Up*, then we have our click (well almost, but bear with me)!

```
func logic(cb, onDown, onUpAndMiss func(interface{})) {
	bl.RegisterShortTerm(bl.EventType_Mouse_Button, func(event bl.Event) {
    	e := event.(*bl.MouseButtonEvent)
        
        if e.ButtonAction == bl.Button_Action_Down {

			gLastNodeId = e.Target.Id
            
		} else if e.ButtonAction == bl.Button_Action_Up {

			// we have a click!
			successCb(Event{bl.Mouse_X, bl.Mouse_X, e.Target})
		}
	})
}
```

What if the node that got *Button Up* is not the same as the node that go the *Button Down* ?  

Well we have to remember the node we were on when these callbacks were registered (ie the node that is looking for the 'Click').

We have a click only if the node that got the button-up event is the same node that originally got the button-down event.

```
func logic(cb, onDown, onUpAndMiss func(interface{})) {

	nodeId := bl.Current_Node.Id
    
	bl.RegisterShortTerm(bl.EventType_Mouse_Button, func(event bl.Event) {
    	e := event.(*bl.MouseButtonEvent)
        
        if e.ButtonAction == bl.Button_Action_Down {

			gLastNodeId = e.Target.Id
            
		} else if e.ButtonAction == bl.Button_Action_Up {

			if gLastNodeId == e.Target.Id {
				// we have a click!
				successCb(Event{bl.Mouse_X, bl.Mouse_X, e.Target})
            }
		}
	})
}
```

Since we are now globally listening to all mouse-button events, lets ignore the ones that are not related to our node. `nodeId` is our node, `e.Target.Id` is the node that got the button-down event.

```
if e.ButtonAction == bl.Button_Action_Down {

	if e.Target.Id != nodeId {
		return
	}

```


Finally, if in the button-up event, we are not on the node that got the initial button-down, then call the `upAndMissCb' and reset the state by setting `gLastNodeId` to nil.

```
func logic(cb, onDown, onUpAndMiss func(interface{})) {

	nodeId := bl.Current_Node.Id
    
	bl.RegisterShortTerm(bl.EventType_Mouse_Button, func(event bl.Event) {
    	e := event.(*bl.MouseButtonEvent)
        
        if e.ButtonAction == bl.Button_Action_Down {

            if e.Target.Id != nodeId {
                return
            }
            
			gLastNodeId = e.Target.Id
            
		} else if e.ButtonAction == bl.Button_Action_Up {

			if gLastNodeId == e.Target.Id {
            
				// we have a click!
				successCb(Event{e.X, e.Y, e.Target})
                
            } else {
   				gLastNodeId = ""

				onUpAndMiss(nil)
            }
		}
	})
}
```

And we are done!
