# Tutorial 6

## Click Plugin

> [On Github: Tutorial 6](tutorial-06-Plugin-Click)

For clarity, some of the code will be hidden.  View the full source code at the repository.

We will skip over material that has been covered in previous tutorials.

&nbsp;

We have been introduced to many of the concepts needed to be able to create our first plugin - `Click`.

As a plugin designer, there is no preconditions on how things should be laid out, except to make usage of plugin as useful and easy as possible.

First, lets design what the plugin does, and how it is used.

## Click plugin API design

Here is what the API will look like:

```
click.On( callback func(interface{}) )

click.On_WithLifeCycle( successCallback, 
						onButtonDown, 
                        onButtonUpAndMiss func(interface{})
```

Here is why...

* `Click` maybe used without instantiating any object

* `Click` will call a callback function when a node is *clicked*

* *clicked* is defined as a mouse-down event followed by a mouse-up event on the same node

* Pressing mouse button on a node, but releasing the mouse button on a different node is *not* a click

* To make the plugin more useful, we can provide `life-cycle` methods
	* When the click life-cycle starts, there will be a callback
    * When the click action completes successfully, there will be a callback
    * When the click action is incomplete (ie. see *clicked* definition above), there will be a callback

* Because the simple case of a successful click notification is the 90% case, we will make it easier to use

* The full life-cycle setup, is more complicated and far less common so we will make that a separate function

## Implementation of Click Plugin

We'll put the code in two files.

![dir](dir.jpg?raw=true "Dir")

The public API in `click.go` and everything else in `logic.go`

### click.go

```
package click

import (
	"github.com/amortaza/go-bellina"
)
```

When the callbacks are called, the information about the click event can be packaged in the `Event` structure below.

> Note that this event is *not* implementing the `bl.Event` interface.  It could have, but it does not.  Therefore, we will not be able to use `bl.FireEvent(event)`.  This is not a problem, because this is not our use-case.  If it is found useful to be able to have listeners for the events generated by our click plugin, then we can easily add that.  

```
type Event struct {
	X, Y int
	Target *bl.Node
}
```

The `(X, Y)` will inform where in the node the click happened (relative to the node's local coordinates).

The `Target` will point to the Node itself.

Because the definition of the plugin callbacks and the event dispatching is happening within the same Bellina frame, the pointer of the node will be valid when the callback is made.

Do *not* hold on Node pointers, because they are invalidated *every* frame.  The node `Id` should be kept instead.

```
// click.On( cb )
func On(cb func(interface{})) {
	logic(cb, nil, nil)
}

// click.On_WithLifeCycle( successCb, downCb, upAndMissCb )
func On_WithLifeCycle(cb, onDown, onUpAndMiss func(interface{})) {
	logic(successCb, downCb, upAndMissCb)
}

```

### logic.go


## Example Usage

And we are done!
